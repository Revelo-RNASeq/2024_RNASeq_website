{
  "hash": "a8627f3218193aead3e34f2326b44759",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: \n  revealjs:\n    navigation-mode: vertical\n    slide-number: false\n    width: 1600\n    height: 900\n    logo: \"images/revelo.png\"\n    footer: \"[home page](https://revelo-rnaseq.github.io/2024_RNASeq_website)\"\n    css: [\"css/theme.css\", \"css/custom.css\"]\n    theme: simple\n    controls: true\nmainfont: \"Times New Roman\"\neditor: source\nfilters:\n  - roughnotation\neditor_options: \n  chunk_output_type: inline\n---\n\n\n\n##  {#TitleSlide data-menu-title=\"TitleSlide\" background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.3\"}\n\n\n\n\n\n\n\n<style>\n  @import url('https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Julius+Sans+One&family=Montserrat:wght@300&family=Rock+Salt&display=swap');\n</style>\n\n::: {style=\"position: absolute; left: 180px; top: 200px; height: 525px; width: 1500px; background-color: #69b1e9; padding: 20px; padding-left: 50px; border-radius: 5px;\"}\n[Introduzione all'RNASeq]{style=\"font-size: 120px; font-weight: bold; line-height: 1em; margin: 0px; font-family: 'Architects Daughter', cursive;\"}\n\n[Introduzione all'analisi RNASeq in R]{style=\"font-size: 40px;font-weight: bold;\"}\n\n[Dipartimento di Biomedicina e Prevenzione]{style=\"font-size: 40px;font-weight: bold;\"}\n\n<br> <br>\n\n[Marco Chiapello, Revelo Datalab]{style=\"font-size: 40px; font-weight: bold;\"}\n\n[2024-11-18]{style=\"font-size: 30px;font-weight: bold;\"}\n:::\n\n\n<!-- #  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Overview]{.f60 .p-span-center}\n\n:::{.p-img-center}\n![](images/pst.jpg){width=1000}\n::: -->\n\n#  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n#  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pre-processing and Quality Control]{.tit .p-span-center}\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTA file\n\n::: {.callout-important icon=\"false\"}\n## Definition\n\nThe FASTA format is a text-based format for representing either nucleotide sequences or amino acid sequences. Both nucleotides and amino acids are represented using single-letter codes. The first line before the nucleotide/amino acid sequence contains the name of the sequence, preceded by the \">\" symbol.\n:::\n\nFile extension could be: fasta, fna, ffn, faa, fa, frn\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTA file\n\n::: {.callout-important icon=\"false\"}\n## Definition\n\nThe FASTA format is a text-based format for representing either nucleotide sequences or amino acid sequences. Both nucleotides and amino acids are represented using single-letter codes. The first line before the nucleotide/amino acid sequence contains the name of the sequence, preceded by the \">\" symbol.\n:::\n\n    >NM_001404729.1 Oryza sativa ribulose bisphosphate carboxylase small chain A\n    CTCAACAGCACTGCTACTGGACATACTCTACTACTACTAGCCAGTAAGCTAGCTAACTAACTACGTGGCT\n    ATGGCCCCCACCGTGATGGCCTCCTCGGCCACCTCCGTGGCTCCATTCCAAGGGCTCAANNNNNNNNNNN\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTA file\n\nMulti-fasta file:\n\n    >MCHU - Calmodulin - Human, rabbit, bovine, rat, and chicken\n    MADQLTEEQIAEFKEAFSLFDKDGDGTITTKELGTVMRSLGQNPTEAELQDMINEVDADGNGTID\n    FPEFLTMMARKMKDTDSEEEIREAFRVFDKDGNGYISAAELRHVMTNLGEKLTDEEVDEMIREA\n    DIDGDGQVNYEEFVQMMTAK\n\n    >NM_001404729.1 Oryza sativa ribulose bisphosphate carboxylase small chain A\n    CTCAACAGCACTGCTACTGGACATACTCTACTACTACTAGCCAGTAAGCTAGCTAACTAACTACGTGGCT\n    ATGGCCCCCACCGTGATGGCCTCCTCGGCCACCTCCGTGGCTCCATTCCAAGGGCTCAANNNNNNNNNNN\n    >HF583486.1 Homo sapiens SOD1 gene for alternative protein SOD1, isolate 144496\n    ATGGATTCCATGTTCATGAGTTTGGAGATAATACAGCAGGCTGTACCAGTGCAGGTCCTCACTTTAATCC\n    TCTATCCAGAAAACACGGTGGGCCAAAGGATGAAGAGAGGCATGTTGGAGACTTGGGCAATGTGA\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTQ format\n\n::: {.callout-important icon=\"false\"}\n## Definition\n\nThe FASTQ format is a text-based format for storing both a biological sequence (usually nucleotide sequence) and its corresponding quality scores. Both the sequence letter and quality score are each encoded with a single ASCII character for brevity.   \n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTQ format\n\n::: {.callout-important icon=\"false\"}\n## Definition\n\nThe FASTQ format is a text-based format for storing both a biological sequence (usually nucleotide sequence) and its corresponding quality scores. Both the sequence letter and quality score are each encoded with a single ASCII character for brevity.   \n:::\n\n::: f30\nA FASTQ file is identified by 4 lines:\n\n- Line 1: begins with the \"@\" symbol and is followed by the sequence identifier (as in FASTA sequences)    \n- Line 2: contains the nucleotide sequence    \n- Line 3: begins with a \"+\" and may contain additional sequence descriptions    \n- Line 4: contains the quality values for the individual nucleotides\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTQ format\n\n::: {.callout-important icon=\"false\"}\n## Definition\nThe FASTQ format is a text-based format for storing both a biological sequence (usually nucleotide sequence) and its corresponding quality scores. Both the sequence letter and quality score are each encoded with a single ASCII character for brevity.   \n\n:::\n\n::: f35\n    @SEQ_ID\n    GATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT\n    +\n    !''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF>>>>>>CCCCCCC65\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTQ format\n\n#### What does \"quality score\" mean?\n\n::: f20\nThe quality score is used to identify the **probability of the correct identification of the corresponding nucleotide**.\n:::\n\n![](images/phred1.png)\n\n::: notes\n-   I numeri da 33 a 126 sono i numeri ASCII corrispondenti alla lettera che indicano\n-   Score più alto osservato 40, quindi molti si fermano li\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTQ format\n\n#### What does \"quality score\" mean?\n\n::: f20\nThe quality score is used to identify the **probability of the correct identification of the corresponding nucleotide**.\n:::\n\n::: centerI\n![](images/phred2.png){width=900}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Raw reads: The Starting Point]{.subtit}\n\n### FASTQ format\n\n- FASTQ files can be very large, so in most cases you won't be dealing with myFile.fastq, but with myFile.fastq.gz.\n\n- This means that the file is compressed, so it is not readable by a text editor without first being decompressed.\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pre-processing Tools]{.subtit}\n\n### FastQC\n\n:::: {.columns}\n::: {.column width=\"60%\" .f30}\n*   **What it is:** \n    * A widely used tool for quality assessment of raw sequencing data.\n*   **What it does:**\n    *   Generates comprehensive reports with various quality metrics.\n    *   Visualizes data quality using interactive plots and graphs.\n*   **Key metrics:**\n    *   Per base sequence quality\n    *   Per sequence quality scores\n    *   Sequence length distribution\n    *   GC content\n    *   Adapter content\n    *   Overrepresented sequences\n:::\n::: {.column width=\"30%\"}\n<br>\n<br>\n[[FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)]{.p-spam.center}\n:::\n:::: \n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pre-processing Tools]{.subtit}\n\n### UMI-tools extract\n\n:::: {.columns}\n::: {.column width=\"50%\" .f25}\n*   **What are UMIs?**\n    *   Unique Molecular Identifiers (UMIs) are short random sequences attached to each cDNA molecule during library preparation.\n    *   They act as \"molecular barcodes\" to identify unique molecules.\n*   **Why are UMIs important?**\n    *   UMIs help to distinguish PCR duplicates from true biological duplicates.\n    *   This improves the accuracy of gene expression quantification, especially for low-abundance transcripts.\n:::\n::: {.column width=\"50%\" .f25}\n*   **What does `UMI-tools extract` do?**\n    *   Identifies and extracts UMIs from sequencing reads.\n    *   Moves UMIs to the read name for downstream analysis.\n    *   Requires information about the UMI location in the read.\n*   **Benefits:**\n    *   Improved accuracy in gene expression quantification.\n    *   Reduced bias due to PCR amplification.<br>\n<br>\n[[UMI-tools](https://umi-tools.readthedocs.io/en/latest/index.html)]{.p-spam.center}\n:::\n:::: \n\n:::{.p-img-center}\n![](images/umi.png){width=1000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pre-processing Tools]{.subtit}\n\n### [FastP](https://github.com/OpenGene/fastp) & [Trim Galore!](https://github.com/FelixKrueger/TrimGalore)\n\n:::: {.columns}\n::: {.column width=\"50%\" .f30}\n*   **Purpose:**  \n    * To clean up raw sequencing data and improve the accuracy of downstream analysis.\n*   **Key functions:**\n    *   **Adapter trimming:**  Remove adapter sequences from reads.\n    *   **Quality trimming:**  Trim low-quality bases from the ends of reads.\n*   **FastP:**\n    *   All-in-one tool with extensive pre-processing features.\n    *   Includes quality filtering, error correction, UMI handling, and more.\n\n:::\n::: {.column width=\"50%\" .f30}\n*   **Trim Galore!:**\n    *   Wrapper script for `cutadapt` (adapter trimming) and often includes `FastQC` (quality assessment).\n    *   Focuses on adapter and quality trimming with optimized parameters.\n*   **Benefits:**\n    *   Improved alignment accuracy.\n    *   Reduced false positives in variant calling and gene expression analysis.\n    *   Increased efficiency of downstream analysis.\n:::\n:::: \n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pre-processing Tools]{.subtit}\n\n### BBSplit\n\n:::: {.columns}\n::: {.column width=\"60%\" .f30}\n*   **What it is:**  \n    * A tool for removing contaminant reads from sequencing data.\n*   **Types of contamination:**\n    *   Microbial DNA or RNA\n    *   Host DNA (in the case of RNA-Seq from host-associated samples)\n    *   Other unwanted sequences\n*   **How it works:**\n    *   Aligns reads to a database of contaminant sequences.\n    *   Removes reads that map to the contaminant database.\n\n:::\n::: {.column width=\"30%\"}\n<br>\n<br>\n[[BBMap](https://sourceforge.net/projects/bbmap/)]{.p-spam.center}\n:::\n:::: \n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pre-processing Tools]{.subtit}\n\n### SortMeRNA\n\n:::: {.columns}\n::: {.column width=\"60%\" .f30}\n*   **What it is:**  \n    * A tool for filtering ribosomal RNA (rRNA) reads from sequencing data.\n*   **Why is it important?**\n    *   rRNA often makes up a large proportion of total RNA.\n    *   Removing rRNA enriches for mRNA and other non-coding RNAs of interest.\n*   **How it works:**\n    *   Uses a database of rRNA sequences to identify and remove rRNA reads.\n    *   Can be used with both single-end and paired-end data.\n\n:::\n::: {.column width=\"30%\"}\n<br>\n<br>\n[[SortMeRNA](https://sortmerna.readthedocs.io/en/latest/)]{.p-spam.center}\n:::\n:::: \n\n#  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.tit .p-span-center}\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### Read Alignment\n\n\n:::: {.columns}\n::: {.column width=\"50%\" .f30}\n*   **Purpose:** \n    * To map sequencing reads to a reference genome or transcriptome.\n*   **Why is it important?**\n    *   Identify the genomic origin of each read.\n    *   Determine which genes or transcripts are expressed.\n    *   Discover genetic variations (SNPs, indels).\n:::\n::: {.column width=\"50%\" .f30}\n*   **Challenges:**\n    *   Reads may contain sequencing errors.\n    *   Reads may map to multiple locations (multi-mapping reads).\n    *   Genomes contain repetitive regions.\n*   **Output:**  A BAM (Binary Alignment/Map) file containing alignment information.\n\n:::\n:::: \n\n:::{.p-img-center}\n![](images/align.png){width=1000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### SAM/BAM Format:  Storing Alignment Information\n\n*   **What it is:**  \n    *   The standard file format for storing read alignments.\n    *   **SAM (Sequence Alignment/Map):**  A text-based format.\n    *   **BAM (Binary Alignment/Map):**  A compressed binary version of SAM.\n*   **Why is it important?**\n    *   Provides a standardized way to store alignment information.\n    *   Allows for efficient storage and retrieval of large alignment datasets.\n    *   Facilitates compatibility between different bioinformatics tools.\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### SAM/BAM Format:  Storing Alignment Information\n\n*   **Content:**\n    *   **Header section**: Contains metadata about the alignment (reference genome, aligner used, etc.).\n\n::: code\n    @RG     ID:1    SM:C5926_BM_IonCode_0118\n    @PG     ID:samtools     PN:samtools    VN:1.16.1    CL:samtools view -H C5926_BM_IonCode_0118.reassembled.bam\n:::\n\n\n::: notes\n-   @RG = read group\n    -   ID = Read group identifier\n    -   SM = Sample\n-   @PG = Program\n    -   ID = Program record identifier\n    -   PN = Program name\n    -   VN = software version\n    -   Cl = command line\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### SAM/BAM Format:  Storing Alignment Information\n\n*   **Alignment section**:  Each line represents a single read and its alignment to the reference.\n    *   Includes information about mapping position, quality scores, alignment flags, and more.\n\n![](images/bam2.png){.absolute top=\"500\" left=\"0\" width=\"800\" height=\"auto\"}\n\n![](images/bam1.png){.absolute top=\"400\" right=\"20\" width=\"550\" height=\"auto\"}\n\n::: notes\n-   11 campi obbligatori\n\n-   Metadati non obbligatori\n\n-   Concise Idiosyncratic Gapped Alignment Report (CIGAR) string\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### [STAR Aligner](https://github.com/alexdobin/STAR)\n\n\n:::: {.columns}\n::: {.column width=\"30%\" .f40}\n![](images/alignment_STAR_step3.png){width=400}\n:::\n::: {.column width=\"70%\" .f30}\n*   **What it is:**  \n    * A widely used splice-aware aligner for RNA-Seq data.\n*   **Key features:**\n    *   Fast and efficient alignment.\n    *   Accurate handling of spliced reads.\n    *   Can detect novel splice junctions.\n    *   Supports various RNA-Seq protocols.\n*   **Advantages:**\n    *   High accuracy\n    *   Speed\n    *   Versatility\n:::\n:::: \n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### [HISAT2](http://daehwankimlab.github.io/hisat2/)\n\n\n:::: {.columns}\n::: {.column width=\"30%\" .f40}\n![](images/alignment_STAR_step3.png){width=400}\n:::\n::: {.column width=\"70%\" .f30}\n*   **What it is:** \n    *   Another popular splice-aware aligner for RNA-Seq.\n*   **Key features:**\n    *   Based on the Burrows-Wheeler transform.\n    *   Fast and memory-efficient.\n    *   Supports both DNA and RNA alignment.\n*   **Comparison to STAR:**\n    *   May be slightly faster for some datasets.\n    *   May have slightly lower accuracy for certain types of reads.\n    *   Choice often depends on specific needs and preferences.\n:::\n:::: \n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### UMI-tools dedup\n\n\n:::: {.columns}\n::: {.column width=\"30%\" .f40}\n![](images/dedup.jpg){width=400}\n:::\n::: {.column width=\"70%\" .f25}\n*   **What it does:**\n    *   Identifies and removes PCR duplicates from RNA-Seq data using Unique Molecular Identifiers (UMIs).\n    *   Groups reads with the same UMI and genomic mapping location.\n    *   Selects the read with the highest quality score as the representative read for each group.\n*   **Why is it important?**\n    *   PCR amplification during library preparation can introduce duplicate reads.\n    *   These duplicates can bias gene expression estimates, especially for low-abundance transcripts.\n    *   `UMI-tools dedup` helps to correct for this bias and improve accuracy.\n*   **Benefits:**\n    *   More accurate gene expression quantification.\n    *   Reduced false positives in differential expression analysis.\n    *   Improved sensitivity for detecting rare transcripts.\n\n\n[[UMI-tools](https://umi-tools.readthedocs.io/en/latest/index.html)]{.p-spam.center}\n:::\n:::: \n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Alignment and Quantification]{.subtit}\n\n### [RSEM](https://github.com/deweylab/RSEM)\n\n\n:::: {.columns}\n::: {.column width=\"50%\" .f40}\n<br>\n<br>\n\n![](images/RSEM.png){width=700}\n:::\n::: {.column width=\"50%\" .f30}\n*   **What it is:**  \n    *   RSEM is a software package for estimating gene and isoform expression levels from RNA-Seq data.\n*   **Key features:**\n    *   Uses a statistical model to estimate transcript abundance from aligned reads.\n    *   Can handle different types of RNA-Seq data (single-end, paired-end).\n    *   Provides various output formats (counts, TPM, FPKM).\n:::\n:::: \n\n::: notes\n\nRPKM (Reads Per Kilobase Million) or FPKM (Fragments Per Kilobase Million). However, TPM (Transcripts Per Kilobase Million) is now becoming quite popular\n\n:::\n\n\n#  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pseudo-aligners]{.tit .p-span-center}\n\n[A New Approach to Quantification]{.f50 .p-span-center}\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pseudo-aligners]{.subtit}\n\n### Fast and Efficient Transcript Abundance Estimation\n\n:::: {.columns}\n::: {.column width=\"60%\" .f30}\n*   **What they are:**  \n    * A class of RNA-Seq quantification tools that do not require exact alignment of reads to a reference genome.\n*   **How they work:**\n    *   Use lightweight algorithms to assign reads to transcripts    \n    *   Effectively \"pseudo-align\" reads to transcripts without determining their precise genomic location.\n*   **Advantages:**\n    *   **Speed:**  Significantly faster than traditional alignment-based methods.\n    *   **Efficiency:**  Reduced computational resources required.\n    *   **Accuracy:**  Comparable or even superior accuracy for transcript quantification.\n:::\n::: {.column width=\"40%\" .f30}\n*   **Popular tools:**\n    *   Salmon\n    *   Kallisto\n*   **Applications:**\n    *   Gene expression profiling\n    *   Differential expression analysis\n    *   Transcript isoform identification\n:::\n:::: \n\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pseudo-aligners]{.subtit}\n\n### Kallisto vs Salmon\n\n::: f30\n| Feature            | [Kallisto]{.f50} ![](images/bear.jpg){width=100} | [Salmon]{.f50} ![](images/salmon.png){width=190}                |\n|---------------------|------------------------|-------------------------|\n| **Algorithm**       | Pseudoalignment (k-mers) | Quasi-mapping (BWT)     |\n| **Speed**           | Fast                   | Faster                  |\n| **Memory Usage**    | Lower                  | Higher                  |\n| **Features**         | Basic                  | More advanced (library types, bootstrapping) |\n| **Accuracy**        | High                   | High                    |\n| **Ease of Use**     | High                   | High                    |\n| **Output Formats**  | Abundance estimates     | Abundance estimates, counts, TPM, etc. |\n| **Applications**   | Gene expression, DE analysis | Gene expression, DE analysis, isoform quantification |\n\n:::\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Pseudo-aligners]{.subtit}\n\n### Salmon Output File Formats\n\n::: {layout=\"[40,-20,60]\"}\n\n![Folder](images/salm1.png)\n\n![quant.sf](images/salmon2.png)\n:::\n\n:::{.notes}\n1. Salmon’s main output is its quantification file => quant.sf\n\n1. cmd_info.json. This is a JSON format file that records the main command line parameters with which Salmon was invoked\n\n1. Auxiliary files: The top-level quantification directory will contain an auxiliary directory called aux_info\n\n     - The auxiliary directory will contain a JSON format file called meta_info.json which contains meta information about the run, including stats such as the number of observed and mapped fragments\n\n     -  If Salmon was run with automatic inference of the library type, information contained in this file is the inferred library type\n\n1. When run in mapping-based mode, the quantification directory will contain a file called lib_format_counts.json. This JSON file reports the number of fragments that had at least one mapping compatible with the designated library format\n\n\n:::\n\nd\n\n#  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Post-alignment Processing]{.tit .p-span-center}\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Post-alignment Processing]{.subtit}\n\n### Refining Your Alignments\n\n::: f30\n*   **What it is:** \n    * A series of steps performed after read alignment to improve data quality and prepare for downstream analysis.\n*   **Key steps:**\n    *   **Deduplication:**  Removing PCR duplicates to avoid bias in gene expression estimates. (Blue line)\n    *   **Generating coverage tracks:**  Visualizing read distribution and assessing sequencing uniformity.\n    *   **(Optional) Other steps:**  Depending on the analysis goals, this may include filtering reads, recalibrating base quality scores, and other processing steps.\n*   **Why is it important?**\n    *   Improves the accuracy and reliability of downstream analysis.\n    *   Reduces noise and bias in the data.\n    *   Facilitates data interpretation and visualization.\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Post-alignment Processing]{.subtit}\n\n### [SAMtools](https://samtools.github.io/): Manipulating and Analyzing Alignments\n\n::: f30\n*   **What it is:**  \n    * A suite of command-line utilities for working with SAM/BAM files.\n    * A Swiss Army Knife for SAM/BAM Files\n*   **Key functions:**\n    *   **`samtools sort`:** Sorts alignments in a BAM file by coordinate.\n        *   Why is sorting important?  Many downstream tools require sorted BAM files for efficient processing.\n    *   **`samtools index`:** Creates an index file for a sorted BAM file.\n        *   Why is indexing important?  Allows for fast retrieval of specific regions of the alignment.\n    *   **`samtools stats`:**  Generates statistics about an alignment file.\n        *   Provides insights into alignment quality, read depth, and other metrics.\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Post-alignment Processing]{.subtit}\n\n### [Picard](https://broadinstitute.github.io/picard/) MarkDuplicates:  Deduplication without UMIs\n\n::: f40\n*   **How it works:**\n    *   Identifies duplicates based on mapping coordinates of reads.\n    *   Marks duplicate reads in the BAM file.\n*   **Considerations:**\n    *   Less accurate than UMI-based methods.\n    *   Can be used when UMIs are not available.\n    *   Often used in combination with other filtering steps.\n:::\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Post-alignment Processing]{.subtit}\n\n\n### [BEDTools](https://bedtools.readthedocs.io/en/latest/) genomecov:  Quantifying Read Depth\n\n::: f40\n*   **What it does:**\n    *   Calculates the number of reads overlapping each position in the genome.\n    *   Outputs a coverage file in various formats (BEDGRAPH, bed, etc.).\n*   **Options:**\n    *   Calculate coverage for different strand orientations.\n    *   Normalize coverage by library size.\n    *   Generate histograms of coverage depth.\n:::\n\n\n#  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Downstream Analysis]{.tit .p-span-center}\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Downstream Analysis]{.subtit}\n\n### [RSeQC](https://rseqc.sourceforge.net):  Comprehensive Quality Assessment of Your RNA-Seq Data\n\n::: f25\n*   **What it is:**  \n    * A suite of tools for RNA-Seq quality control and analysis.\n*   **Key functions:**\n    *   **Read distribution:**  Assess the distribution of reads across different genomic features (e.g., coding regions, introns, UTRs).\n    *   **Gene body coverage:**  Evaluate the uniformity of coverage across gene bodies.\n    *   **Strand specificity:**  Check the strand specificity of the library.\n    *   **Junction saturation:**  Determine if sufficient sequencing depth has been achieved for junction detection.\n    *   **Other QC metrics:**  Assess rRNA contamination, insert size distribution, and more.\n*   **Benefits:**\n    *   Provides comprehensive quality assessment of RNA-Seq data.\n    *   Identifies potential biases and issues in library preparation or sequencing.\n    *   Helps to ensure the reliability and accuracy of downstream analysis.\n\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Downstream Analysis]{.subtit}\n\n### [Preseq](http://smithlabresearch.org/software/preseq/):  Assessing the Diversity of Your Library\n\n::: f25\n*   **What it is:**  A tool for estimating the complexity of a sequencing library.\n*   **Why is library complexity important?**\n    *   Library complexity refers to the number of unique DNA fragments in your library.\n    *   Higher complexity means a more diverse representation of the original RNA population.\n    *   Low complexity can lead to reduced sequencing efficiency and biased results.\n*   **What does Preseq do?**\n    *   Uses statistical modeling to predict the number of unique reads that would be obtained with deeper sequencing.\n    *   Helps to assess whether additional sequencing is likely to yield new information.\n    *   Can be used to compare the complexity of different libraries.\n*   **Benefits:**\n    *   Optimize sequencing depth.\n    *   Avoid unnecessary sequencing costs.\n    *   Improve the quality and efficiency of RNA-Seq experiments.\n:::\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Downstream Analysis]{.subtit}\n\n### [Qualimap RNA-Seq](http://qualimap.conesalab.org):  A Deep Dive into Your RNA-Seq Data\n\n\n::: f25\n*   **What it is:**  \n    * A comprehensive tool for quality control and analysis of RNA-Seq data.\n*   **Key features:**\n    *   **Alignment quality:**  Assesses mapping quality, mismatch rates, and indel rates.\n    *   **Coverage analysis:**  Evaluates coverage uniformity across genes and transcripts.\n    *   **Junction analysis:**  Examines splice junctions and identifies non-canonical junctions.\n    *   **Transcript coverage:**  Assesses coverage of known transcripts and identifies potential novel transcripts.\n    *   **rRNA content:**  Estimates the proportion of rRNA reads in the data.\n    *   **5' and 3' bias:**  Detects biases in read coverage towards the 5' or 3' ends of transcripts.\n*   **Benefits:**\n    *   Provides detailed insights into the quality of RNA-Seq alignments.\n    *   Identifies potential biases and technical artifacts.\n    *   Helps to ensure the reliability and accuracy of downstream analysis.\n\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Downstream Analysis]{.subtit}\n\n### Kraken2:  Identifying Microbial Communities in Your Samples\n\n:::: {.columns}\n::: {.column width=\"40%\" .f40}\n![](images/kraken.png){width=700}\n:::\n::: {.column width=\"60%\" .f25}\n*   **What it is:**  \n    * A fast and accurate tool for assigning taxonomic labels to sequencing reads.\n*   **Why is it useful for RNA-Seq?**\n    *   RNA-Seq data can sometimes contain reads from microbial organisms (e.g., in microbiome studies, host-associated samples).\n    *   Kraken2 can identify and classify these microbial reads, providing insights into the microbial community present in the sample.\n*   **How it works:**\n    *   Assigns taxonomic classifications to reads based on the best match.\n*   **Benefits:**\n    *   Fast and efficient classification.\n    *   Accurate identification of microbial species.\n    *   Can be used with both DNA and RNA sequencing data.\n:::\n:::: \n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Downstream Analysis]{.subtit}\n\n### Differential Expression:  Finding the Genes that Matter\n\n\n::: f30\n*   **What it is:**  \n    * Identifying genes that are expressed at significantly different levels between two or more conditions (e.g., treated vs. control, healthy vs. diseased).\n*   **Why is it important?**\n    *   Uncover genes involved in specific biological processes or disease states.\n    *   Identify potential biomarkers or therapeutic targets.\n*   **Tools:**\n    *   `DESeq2`:  A popular R package for differential expression analysis.\n    *   `edgeR`:  Another widely used R package.\n    *   `limma`:  A flexible package for linear modeling and differential expression analysis.\n\n\n:::\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n[Downstream Analysis]{.subtit}\n\n### [MultiQC](https://seqera.io/examples/rna-seq/multiqc_report.html):  Your One-Stop Shop for QC Reports\n\n::: f25\n*   **What it is:**  A tool that aggregates results from multiple bioinformatics tools into a single HTML report.\n*   **Why is it useful for RNA-Seq?**\n    *   RNA-Seq analysis involves multiple QC steps (FastQC, SortMeRNA, Trim Galore!, etc.).\n    *   MultiQC combines the results from these tools into a user-friendly report.\n    *   This saves time and simplifies the QC assessment process.\n*   **Key features:**\n    *   Supports a wide range of bioinformatics tools.\n    *   Generates interactive plots and tables for easy visualization.\n    *   Highlights potential issues and inconsistencies in the data.\n    *   Facilitates comparison of QC metrics across multiple samples.\n*   **Benefits:**\n    *   Saves time and effort in QC assessment.\n    *   Improves clarity and organization of QC results.\n    *   Facilitates data interpretation and decision-making.\n:::\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n:::{.p-img-center}\n![](images/nfcore.png){width=2000}\n:::\n\n\n##  {background-image=\"images/back001.jpg\" background-size=\"cover\" background-opacity=\"0.1\"}\n\n### Differential Gene Expression (DGE)\n\n<br>\n\n:::{.callout-important}\nThe goal of differential expression testing is to determine which genes are expressed at different levels between conditions.\n:::\n\n:::{.fragment .fade-in fragment-index=1 .scrollable}\n\n:::{.f20}\nThese tools perform normalization and calculate the abundance of each gene expressed in a sample:\n\n\n- **ABSSeq** a new RNA-Seq analysis method based on modelling absolute expression differences.\n- **ALDEx2** is a tool for comparative analysis of high-throughput sequencing data. ALDEx2 uses compositional data analysis and can be applied to RNAseq, 16S rRNA gene sequencing, metagenomic sequencing, and selective growth experiments.\n- **Alexa-Seq** is a pipeline that makes possible to perform gene expression analysis, transcript specific expression analysis, exon junction expression and quantitative alternative analysis. Allows wide alternative expression visualization, statistics and graphs.\n- **ARH-seq** – identification of differential splicing in RNA-seq data.\n- **ASC[56]\n-** Ballgown\n- **BaySeq** is a Bioconductor package to identify differential expression using next-generation sequencing data, via empirical Bayesian methods. There is an option of using the \"snow\" package for parallelisation of computer data processing, recommended when dealing with large data sets.\n- **GMNB[57]** is a Bayesian method to temporal gene differential expression analysis across different phenotypes or treatment conditions that naturally handles the heterogeneity of sequencing depth in different samples, removing the need for ad-hoc normalization.\n- **BBSeq\n-** BitSeq (Bayesian Inference of Transcripts from Sequencing Data) is an application for inferring expression levels of individual transcripts from sequencing (RNA-Seq) data and estimating differential expression (DE) between conditions.\n- **CEDER** Accurate detection of differentially expressed genes by combining significance of exons using RNA-Seq.\n- **CPTRA** The CPTRA package is for analyzing transcriptome sequencing data from different sequencing platforms. It combines advantages of 454, Illumina GAII, or other platforms and can perform sequence tag alignment and annotation, expression quantification tasks.\n- **casper** is a Bioconductor package to quantify expression at the isoform level. It combines using informative data summaries, flexible estimation of experimental biases and statistical precision considerations which (reportedly) provide substantial reductions in estimation error.\n- **Cufflinks/Cuffdiff** is appropriate to measure global de novo transcript isoform expression. It performs assembly of transcripts, estimation of abundances and determines differential expression (Cuffdiff) and regulation in RNA-Seq samples.[58]\n- **DESeq** is a Bioconductor package to perform differential gene expression analysis based on negative binomial distribution.\n- **DEGSeq\n-** Derfinder Annotation-agnostic differential expression analysis of RNA-seq data at base-pair resolution via the DER Finder approach.\n- **DEvis** is a powerful, integrated solution for the analysis of differential expression data. Using DESeq2 as a framework, DEvis provides a wide variety of tools for data manipulation, visualization, and project management.\n- **DEXSeq** is Bioconductor package that finds differential differential exon usage based on RNA-Seq exon counts between samples. DEXSeq employs negative binomial distribution, provides options to visualization and exploration of the results.\n- **DEXUS** is a Bioconductor package that identifies differentially expressed genes in RNA-Seq data under all possible study designs such as studies without replicates, without sample groups, and with unknown conditions.[59] In contrast to other methods, DEXUS does not need replicates to detect differentially expressed transcripts, since the replicates (or conditions) are estimated by the EM method for each transcript.\n- **DGEclust** is a Python package for clustering expression data from RNA-seq, CAGE and other NGS assays using a Hierarchical Dirichlet Process Mixture Model. The estimated cluster configurations can be post-processed in order to identify differentially expressed genes and for generating gene- and sample-wise dendrograms and heatmaps.[60]\n- **DiffSplice** is a method for differential expression detection and visualization, not dependent on gene annotations. This method is supported on identification of alternative splicing modules (ASMs) that diverge in the different isoforms. A non-parametric test is applied to each ASM to identify significant differential transcription with a measured false discovery rate.\n- **EBSeq** is a Bioconductor package for identifying genes and isoforms differentially expressed (DE) across two or more biological conditions in an RNA-seq experiment. It also can be used to identify DE contigs after performing de novo transcriptome assembly. While performing DE analysis on isoforms or contigs, different isoform/contig groups have varying estimation uncertainties. EBSeq models the varying uncertainties using an empirical Bayes model with different priors.\n- **EdgeR** is a R package for analysis of differential expression of data from DNA sequencing methods, like RNA-Seq, SAGE or ChIP-Seq data. edgeR employs statistical methods supported on negative binomial distribution as a model for count variability.\n- **EdgeRun** an R package for sensitive, functionally relevant differential expression discovery using an unconditional exact test.\n- **EQP** The exon quantification pipeline (EQP): a comprehensive approach to the quantification of gene, exon and junction expression from RNA-seq data.\n- **ESAT** The End Sequence Analysis Toolkit (ESAT) is specially designed to be applied for quantification of annotation of specialized RNA-Seq gene libraries that target the 5' or 3' ends of transcripts.\n- **eXpress** performance includes transcript-level RNA-Seq quantification, allele-specific and haplotype analysis and can estimate transcript abundances of the multiple isoforms present in a gene. Although could be coupled directly with aligners (like Bowtie), eXpress can also be used with de novo assemblers and thus is not needed a reference genome to perform alignment. It runs on Linux, Mac and Windows.\n- **ERANGE** performs alignment, normalization and quantification of expressed genes.\n- **featureCounts** an efficient general-purpose read quantifier.\n- **FDM\n-** FineSplice Enhanced splice junction detection and estimation from RNA-Seq data.\n- **GFOLD[61]** Generalized fold change for ranking differentially expressed genes from RNA-seq data.\n- **globalSeq[62]** Global test for counts: testing for association between RNA-Seq and high-dimensional data.\n- **GPSeq** This is a software tool to analyze RNA-seq data to estimate gene and exon expression, identify differentially expressed genes, and differentially spliced exons.\n- **IsoDOT** – Differential RNA-isoform Expression.\n- **Limma** Limma powers differential expression analyses for RNA-sequencing and microarray studies.\n- **LPEseq** accurately test differential expression with a limited number of replicates.\n- **Kallisto** \"Kallisto is a program for quantifying abundances of transcripts from RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads. It is based on the novel idea of pseudoalignment for rapidly determining the compatibility of reads with targets, without the need for alignment. On benchmarks with standard RNA-Seq data, kallisto can quantify 30 million human reads in less than 3 minutes on a Mac desktop computer using only the read sequences and a transcriptome index that itself takes less than 10 minutes to build.\"\n- **MATS** Multivariate Analysis of Transcript Splicing (MATS).\n- **MAPTest** provides a general testing framework for differential expression analysis of RNA-Seq time course experiment. Method of the pack is based on latent negative-binomial Gaussian mixture model. The proposed test is optimal in the maximum average power. The test allows not only identification of traditional DE genes but also testing of a variety of composite hypotheses of biological interest.[63]\n- **MetaDiff** Differential isoform expression analysis using random-effects meta-regression.\n- **metaseqR** is a Bioconductor package that detects differentially expressed genes from RNA-Seq data by combining six statistical algorithms using weights estimated from their performance with simulated data estimated from real data, either public or user-based. In this way, metaseqR optimizes the tradeoff between precision and sensitivity.[64] In addition, metaseqR creates a detailed and interactive report with a variety of diagnostic and exploration plots and auto-generated text.\n- **MMSEQ** is a pipeline for estimating isoform expression and allelic imbalance in diploid organisms based on RNA-Seq. The pipeline employs tools like Bowtie, TopHat, ArrayExpressHTS and SAMtools. Also, edgeR or DESeq to perform differential expression.\n- **MultiDE\n-** Myrna is a pipeline tool that runs in a cloud environment (Elastic MapReduce) or in a unique computer for estimating differential gene expression in RNA-Seq datasets. Bowtie is employed for short read alignment and R algorithms for interval calculations, normalization, and statistical processing.\n- **NEUMA** is a tool to estimate RNA abundances using length normalization, based on uniquely aligned reads and mRNA isoform models. NEUMA uses known transcriptome data available in databases like RefSeq.\n- **NOISeq** NOISeq is a non-parametric approach for the identification of differentially expressed genes from count data or previously normalized count data. NOISeq empirically models the noise distribution of count changes by contrasting fold-change differences (M) and absolute expression differences (D) for all the features in samples within the same condition.\n- **NPEBseq** is a nonparametric empirical Bayesian-based method for differential expression analysis.\n- **NSMAP** allows inference of isoforms as well estimation of expression levels, without annotated information. The exons are aligned and splice junctions are identified using TopHat. All the possible isoforms are computed by a combination of the detected exons.\n- **NURD** an implementation of a new method to estimate isoform expression from non-uniform RNA-seq data.\n- **PANDORA** An R package for the analysis and result reporting of RNA-Seq data by combining multiple statistical algorithms.\n- **PennSeq** PennSeq: accurate isoform-specific gene expression quantification in RNA-Seq by modeling non-uniform read distribution.\n- **QuasR** Quantify and Annotate Short Reads in R.\n- **RapMap** A Rapid, Sensitive and Accurate Tool for Mapping RNA-seq Reads to Transcriptomes.\n- **recursiveCorPlot** Correlation based clustering for RNA-seq data (+ ggplot corrplot-like interface - R-package: recursiveCorPlot).[65]\n- **RNAeXpress** Can be run with Java GUI or command line on Mac, Windows, and Linux. It can be configured to perform read counting, feature detection or GTF comparison on mapped rnaseq data.\n- **Rcount** Rcount: simple and flexible RNA-Seq read counting.\n- **rDiff** is a tool that can detect differential RNA processing (e.g. alternative splicing, polyadenylation or ribosome occupancy).\n- **RNASeqPower** Calculating samples Size estimates for RNA Seq studies. R package version.\n- **RNA-Skim** RNA-Skim: a rapid method for RNA-Seq quantification at transcript-level.\n- **rSeq** rSeq is a set of tools for RNA-Seq data analysis. It consists of programs that deal with many aspects of RNA-Seq data analysis, such as read quality assessment, reference sequence generation, sequence mapping, gene and isoform expressions (RPKMs) estimation, etc.\n- **RSEM\n-** rQuant is a web service (Galaxy (computational biology) installation) that determines abundances of transcripts per gene locus, based on quadratic programming. rQuant is able to evaluate biases introduced by experimental conditions. A combination of tools is employed: PALMapper (reads alignment), mTiM and mGene (inference of new transcripts).\n- **Salmon** is a software tool for computing transcript abundance from RNA-seq data using either an alignment-free (based directly on the raw reads) or an alignment-based (based on pre-computed alignments) approach. It uses an online stochastic optimization approach to maximize the likelihood of the transcript abundances under the observed data. The software itself is capable of making use of many threads to produce accurate quantification estimates quickly. It is part of the Sailfish suite of software, and is the successor to the Sailfish tool.\n- **SAJR** is a java-written read counter and R-package for differential splicing analysis. It uses junction reads to estimate exon exclusion and reads mapped within exon to estimate its inclusion. SAJR models it by GLM with quasibinomial distribution and uses log likelihood test to assess significance.\n- **Scotty** Performs power analysis to estimate the number of replicates and depth of sequencing required to call differential expression.\n- **Seal** alignment-free algorithm to quantify sequence expression by matching kmers between raw reads and a reference transcriptome. Handles paired reads and alternate isoforms, and uses little memory. Accepts all common read formats, and outputs read counts, coverage, and FPKM values per reference sequence. Open-source, written in pure Java; supports all platforms with no recompilation and no other dependencies. Distributed with BBMap. (Seal - Sequence Expression AnaLyzer - is unrelated to the SEAL distributed short-read aligner.)\n- **semisup[66]** Semi-supervised mixture model: detecting SNPs with interactive effects on a quantitative trait\n- **Sleuth** is a program for analysis of RNA-Seq experiments for which transcript abundances have been quantified with kallisto.\n- **SplicingCompass** differential splicing detection using RNA-Seq data.\n- **sSeq** The purpose of this R package is to discover the genes that are differentially expressed between two conditions in RNA-seq experiments.\n- **StringTie** is an assembler of RNA-Seq alignments into potential transcripts. It uses a novel network flow algorithm as well as an optional de novo assembly step to assemble and quantitate full-length transcripts representing multiple splice variants for each gene locus. It was designed as a successor to Cufflinks (its developers include some of the Cufflinks developers) and has many of the same features.\n- **TIGAR** Transcript isoform abundance estimation method with gapped alignment of RNA-Seq data by variational Bayesian inference.\n- **TimeSeq** Detecting Differentially Expressed Genes in Time Course RNA-Seq Data.\n- **TPMCalculator[67]** one-step software to quantify mRNA abundance of genomic features.\n- WemIQ is a software tool to quantify isoform expression and exon splicing ratios from RNA-seq data accurately and robustly.\n\nFrom: https://en.wikipedia.org/wiki/List_of_RNA-Seq_bioinformatics_tools\n:::\n:::\n\n#  {background-image=\"images/qmark.jpg\" background-size=\"cover\" background-opacity=\"0.7\"}\n\n\n::: {style=\"position: absolute; left: 980px; top: 450px;\"}\n[Domande?]{style=\"font-size: 130px; font-weight: bold; color: white\"}\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}